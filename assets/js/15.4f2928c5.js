(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{166:function(t,e,s){t.exports=s.p+"assets/img/run.0369bedd.jpeg"},243:function(t,e,s){"use strict";s.r(e);var a=[function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("div",{staticClass:"content"},[a("h1",{attrs:{id:"运行原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#运行原理","aria-hidden":"true"}},[t._v("#")]),t._v(" 运行原理")]),t._v(" "),a("p",[t._v("全面了解mysql的运行机制，从而了解当前系统的瓶颈，找到优化方案。")]),t._v(" "),a("br"),t._v(" "),a("img",{staticStyle:{width:"500px"},attrs:{src:s(166)}}),t._v(" "),a("ul",[a("li",[t._v("从上图可以清晰看出mysql的内部架构，可以清楚的看到Mysql是由\n"),a("ul",[a("li",[t._v("连接池、")]),t._v(" "),a("li",[t._v("Connection Pool，")]),t._v(" "),a("li",[t._v("SQL接口")]),t._v(" "),a("li",[t._v("解析器")]),t._v(" "),a("li",[t._v("优化器")]),t._v(" "),a("li",[t._v("缓存")]),t._v(" "),a("li",[t._v("存储引擎组成的。")])])])]),t._v(" "),a("h2",{attrs:{id:"说明"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#说明","aria-hidden":"true"}},[t._v("#")]),t._v(" 说明")]),t._v(" "),a("h3",{attrs:{id:"connectors"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#connectors","aria-hidden":"true"}},[t._v("#")]),t._v(" Connectors")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("Connectors")]),t._v(" "),a("p",[t._v("指的是不同语言中与SQL的交互")])]),t._v(" "),a("h3",{attrs:{id:"management-serveices-utilities："}},[a("a",{staticClass:"header-anchor",attrs:{href:"#management-serveices-utilities：","aria-hidden":"true"}},[t._v("#")]),t._v(" Management Serveices & Utilities：")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("系统管理和控制工具")]),t._v(" "),a("ul",[a("li")])]),t._v(" "),a("h3",{attrs:{id:"connection-pool"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#connection-pool","aria-hidden":"true"}},[t._v("#")]),t._v(" Connection Pool")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("连接池")]),t._v(" "),a("p",[t._v("管理缓冲用户连接，线程处理等需要缓存的需求。\n负责监听对 MySQL Server 的各种请求，接收连接请求，转发所有连接请求到线程管理模块。每一个连接上 MySQL Server 的客户端请求都会被分配（或创建）一个连接线程为其单独服务。而连接线程的主要工作就是负责 MySQL Server 与客户端的通信，\n接受客户端的命令请求，传递 Server 端的结果信息等。线程管理模块则负责管理维护这些连接线程。包括线程的创建，线程的 cache 等。")])]),t._v(" "),a("h3",{attrs:{id:"sql-interface"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#sql-interface","aria-hidden":"true"}},[t._v("#")]),t._v(" SQL Interface")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("SQL接口")]),t._v(" "),a("p",[t._v("接受用户的SQL命令，并且返回用户需要查询的结果。比如select from就是调用SQL Interface")])]),t._v(" "),a("h3",{attrs:{id:"parser"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#parser","aria-hidden":"true"}},[t._v("#")]),t._v(" Parser")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("解析器")]),t._v(" "),a("p",[t._v("SQL命令传递到解析器的时候会被解析器验证和解析。解析器是由Lex和YACC实现的，是一个很长的脚本。\n在 MySQL中我们习惯将所有 Client 端发送给 Server 端的命令都称为 query ，在 MySQL Server 里面，连接线程接收到客户端的一个 Query 后，会直接将该 query 传递给专门负责将各种 Query 进行分类然后转发给各个对应的处理模块。\n主要功能：")]),t._v(" "),a("ul",[a("li",[t._v("将SQL语句进行语义和语法的分析，分解成数据结构，然后按照不同的操作类型进行分类，然后做出针对性的转发到后续步骤，以后SQL语句的传递和处理就是基于这个结构的。")]),t._v(" "),a("li",[t._v("如果在分解构成中遇到错误，那么就说明这个sql语句是不合理的")])])]),t._v(" "),a("h3",{attrs:{id:"optimizer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#optimizer","aria-hidden":"true"}},[t._v("#")]),t._v(" Optimizer")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("查询优化器")]),t._v(" "),a("p",[t._v("SQL语句在查询之前会使用查询优化器对查询进行优化。就是优化客户端请求的 query（sql语句） ，根据客户端请求的 query 语句，和数据库中的一些统计信息，在一系列算法的基础上进行分析，得出一个最优的策略，告诉后面的程序如何取得这个 query 语句的结果\n他使用的是“选取-投影-联接”策略进行查询。\n用一个例子就可以理解： select uid,name from user where gender = 1;\n这个select 查询先根据where 语句进行选取，而不是先将表全部查询出来以后再进行gender过滤\n这个select查询先根据uid和name进行属性投影，而不是将属性全部取出以后再进行过滤\n将这两个查询条件联接起来生成最终查询结果")])]),t._v(" "),a("h3",{attrs:{id:"cache和buffer"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#cache和buffer","aria-hidden":"true"}},[t._v("#")]),t._v(" Cache和Buffer")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("查询缓存")]),t._v(" "),a("p",[t._v("他的主要功能是将客户端提交 给MySQL 的 Select 类 query 请求的返回结果集 cache 到内存中，与该 query 的一个 hash 值 做\n一个对应。该 Query 所取数据的基表发生任何数据的变化之后， MySQL 会自动使该 query 的Cache 失效。在读写比例非常高的应用系统中， Query Cache 对性能的提高是非常显著的。当然它对内存的消耗也是非常大的。\n如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等")])]),t._v(" "),a("h3",{attrs:{id:"pluggable-storage-engines"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#pluggable-storage-engines","aria-hidden":"true"}},[t._v("#")]),t._v(" Pluggable Storage Engines")]),t._v(" "),a("div",{staticClass:"tip custom-block"},[a("p",{staticClass:"custom-block-title"},[t._v("存储引擎接口")]),t._v(" "),a("p",[t._v("存储引擎接口模块可以说是 MySQL 数据库中最有特色的一点了。目前各种数据库产品中，基本上只有 MySQL 可以实现其底层数据存储引擎的插件式管理。这个模块实际上只是 一个抽象类，但正是因为它成功地将各种数据处理高度抽象化，才成就了今天 MySQL 可插拔存储引擎的特色。\n从图2还可以看出，MySQL区别于其他数据库的最重要的特点就是其插件式的表存储引擎。MySQL插件式的存储引擎架构提供了一系列标准的管理和服务支持，这些标准与存储引擎本身无关，可能是每个数据库系统本身都必需的，如SQL分析器和优化器等，而存储引擎是底层物理结构的实现，每个存储引擎开发者都可以按照自己的意愿来进行开发。\n注意：存储引擎是基于表的，而不是数据库")])])])}],r=s(0),i=Object(r.a)({},function(){this.$createElement;this._self._c;return this._m(0)},a,!1,null,null,null);i.options.__file="run.md";e.default=i.exports}}]);