(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{188:function(e,a,t){e.exports=t.p+"assets/img/WechatIMG1256.daf94428.png"},258:function(e,a,t){"use strict";t.r(a);var h=[function(){var e=this,a=e.$createElement,h=e._self._c||a;return h("div",{staticClass:"content"},[h("h1",{attrs:{id:"核心数据结构-hashtable"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#核心数据结构-hashtable","aria-hidden":"true"}},[e._v("#")]),e._v(" 核心数据结构 - hashTable")]),e._v(" "),h("div",{staticClass:"tip custom-block"},[h("p",{staticClass:"custom-block-title"},[e._v("TIP")]),e._v(" "),h("p",[e._v("HashTable是Zend的核心数据结构，在PHP里面几乎并用来实现所有常见功能，我们知道的PHP数组即是其典型应用，此外，在zend内部，如函数符号表、全局变量等也都是基于hash table来实现。")]),e._v(" "),h("p",[h("code",[e._v("函数符号表")]),e._v(" "),h("code",[e._v("全局变量")]),e._v(" "),h("code",[e._v("关联数组")]),e._v(" "),h("code",[e._v("索引数组")])])]),e._v(" "),h("h2",{attrs:{id:"特点"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#特点","aria-hidden":"true"}},[e._v("#")]),e._v(" 特点")]),e._v(" "),h("p",[e._v("PHP的hash table具有如下特点：")]),e._v(" "),h("ul",[h("li",[e._v("支持典型的key->value查询")]),e._v(" "),h("li",[e._v("可以当做数组使用")]),e._v(" "),h("li",[e._v("添加、删除节点是 O(1) 复杂度")]),e._v(" "),h("li",[e._v("key支持混合类型：同时存在关联数组合索引数组")]),e._v(" "),h("li",[e._v('Value支持混合类型：array ("string", 2332)')]),e._v(" "),h("li",[e._v("支持线性遍历：如foreach")])]),e._v(" "),h("h2",{attrs:{id:"结构"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#结构","aria-hidden":"true"}},[e._v("#")]),e._v(" 结构")]),e._v(" "),h("p",[e._v("Zend hash table实现了典型的hash表散列结构，同时通过附加一个双向链表，提供了正向、反向遍历数组的功能。其结构如下图：")]),e._v(" "),h("img",{staticStyle:{width:"400px"},attrs:{src:t(188)}}),e._v(" "),h("p",[e._v("可以看到，在hash table中既有key->value形式的散列结构，也有双向链表模式，使得它能够非常方便的支持快速查找和线性遍历。")]),e._v(" "),h("h2",{attrs:{id:"应用"}},[h("a",{staticClass:"header-anchor",attrs:{href:"#应用","aria-hidden":"true"}},[e._v("#")]),e._v(" 应用")]),e._v(" "),h("ul",[h("li",[e._v("散列结构：")])]),e._v(" "),h("p",[e._v("Zend的散列结构是典型的hash表模型，通过链表的方式来解决冲突。需要注意的是zend的hash table是一个自增长的数据结构，当hash表数目满了之后，其本身会动态以2倍的方式扩容并重新元素位置。初始大小均为8。另外，在进行key->value快速查找时候，zend本身还做了一些优化，通过空间换时间的方式加快速度。比如在每个元素中都会用一个变量nKeyLength标识key的长度以作快速判定。")]),e._v(" "),h("ul",[h("li",[e._v("双向链表：")])]),e._v(" "),h("p",[e._v("Zend hash table通过一个链表结构，实现了元素的线性遍历。理论上，做遍历使用单向链表就够了，之所以使用双向链表，主要目的是为了快速删除，避免遍历。Zend hash table是一种复合型的结构，作为数组使用时，即支持常见的关联数组也能够作为顺序索引数字来使用，甚至允许2者的混合。")]),e._v(" "),h("ul",[h("li",[e._v("PHP关联数组：")])]),e._v(" "),h("p",[e._v("关联数组是典型的hash_table应用。一次查询过程经过如下几步（从代码可以看出，这是一个常见的hash查询过程，并增加一些快速判定加速查找。）：\ngetKeyHashValue h; index = n & nTableMask; Bucket *p = arBucket[index];                                         while (p) {     if ((p->h == h) & (p->nKeyLength == nKeyLength)) {                                 RETURN p->data;    } p=p->next; }RETURN FALTURE;")]),e._v(" "),h("ul",[h("li",[e._v("PHP索引数组：")])]),e._v(" "),h("p",[e._v("索引数组就是我们常见的数组，通过下标访问。例如 $arr[0]，Zend HashTable内部进行了归一化处理，对于index类型key同样分配了hash值和nKeyLength(为0)。内部成员变量nNextFreeElement就是当前分配到的最大id，每次push后自动加一。正是这种归一化处理，PHP才能够实现关联和非关联的混合。由于push操作的特殊性，索引key在PHP数组中先后顺序并不是通过下标大小来决定，而是由push的先后决定。例如 $arr[1] = 2; $arr[2] = 3; 对于double类型的key，Zend HashTable会将他当做索引key处理")])])}],s=t(0),_=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},h,!1,null,null,null);_.options.__file="hash_table.md";a.default=_.exports}}]);