(window.webpackJsonp=window.webpackJsonp||[]).push([[69],{260:function(a,e,t){"use strict";t.r(e);var v=t(0),s=Object(v.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"变量"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#变量","aria-hidden":"true"}},[a._v("#")]),a._v(" 变量")]),a._v(" "),t("div",{staticClass:"tip custom-block"},[t("p",{staticClass:"custom-block-title"},[a._v("TIP")]),a._v(" "),t("p",[a._v("PHP是一门弱类型语言，本身不严格区分变量的类型。PHP在变量申明的时候不需要指定类型。PHP在程序运行期间可能进行变量类型的隐示转换。和其他强类型语言一样，程序中也可以进行显示的类型转换。PHP变量可以分为简单类型(int、string、bool)、集合类型(array resource object)和常量(const)。以上所有的变量在底层都是同一种结构 zval。")]),a._v(" "),t("p",[a._v("Zval是zend中另一个非常重要的数据结构，用来标识并实现PHP变量")]),a._v(" "),t("p",[t("code",[a._v("Zval")]),a._v(" "),t("code",[a._v("Zend")]),a._v(" "),t("code",[a._v("PHP变量")])])]),a._v(" "),t("h2",{attrs:{id:"zval结构"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#zval结构","aria-hidden":"true"}},[a._v("#")]),a._v(" Zval结构")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("Zval主要由三部分组成：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("type：指定了变量所述的类型（整数、字符串、数组等）")])]),a._v(" "),t("li",[t("p",[a._v("refcount&is_ref：用来实现引用计数(后面具体介绍)")])]),a._v(" "),t("li",[t("p",[a._v("value：核心部分，存储了变量的实际数据")]),a._v(" "),t("p",[a._v("Zvalue是用来保存一个变量的实际数据。因为要存储多种类型，所以zvalue是一个union，也由此实现了弱类型。")])])])]),a._v(" "),t("li",[t("p",[a._v("PHP变量类型和其实际存储对应关系如下：")]),a._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("IS_LONG   -> lvalue\nIS_DOUBLE -> dvalue\nIS_ARRAY  -> ht\nIS_STRING -> str\nIS_RESOURCE -> lvalue\n")])]),a._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[a._v("1")]),t("br"),t("span",{staticClass:"line-number"},[a._v("2")]),t("br"),t("span",{staticClass:"line-number"},[a._v("3")]),t("br"),t("span",{staticClass:"line-number"},[a._v("4")]),t("br"),t("span",{staticClass:"line-number"},[a._v("5")]),t("br")])])])]),a._v(" "),t("h3",{attrs:{id:"引用计数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用计数","aria-hidden":"true"}},[a._v("#")]),a._v(" 引用计数")]),a._v(" "),t("p",[a._v("引用计数在内存回收、字符串操作等地方使用非常广泛。PHP中的变量就是引用计数的典型应用。")]),a._v(" "),t("h3",{attrs:{id:"整数和浮点数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#整数和浮点数","aria-hidden":"true"}},[a._v("#")]),a._v(" 整数和浮点数")]),a._v(" "),t("p",[a._v("整数、浮点数是PHP中的基础类型之一，也是一个简单型变量。对于整数和浮点数，在zvalue中直接存储对应的值。其类型分别是long和double。")]),a._v(" "),t("p",[a._v("从zvalue结构中可以看出，对于整数类型，和c等强类型语言不同，PHP是不区分int、unsigned int、long、long long等类型的，对它来说，整数只有一种类型也就是long。由此，可以看出，在PHP里面，整数的取值范围是由编译器位数来决定而不是固定不变的。")]),a._v(" "),t("p",[a._v("对于浮点数，类似整数，它也不区分float和double而是统一只有double一种类型。")]),a._v(" "),t("p",[a._v("在PHP中，如果整数范围越界了怎么办？这种情况下会自动转换为double类型，这个一定要小心，很多trick都是由此产生。")]),a._v(" "),t("h3",{attrs:{id:"字符和字符串"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#字符和字符串","aria-hidden":"true"}},[a._v("#")]),a._v(" 字符和字符串")]),a._v(" "),t("p",[a._v("和整数一样，字符变量也是PHP中的基础类型和简单型变量。通过zvalue结构可以看出，在PHP中，字符串是由由指向实际数据的指针和长度结构体组成，这点和c++中的string比较类似。由于通过一个实际变量表示长度，和c不同，它的字符串可以是2进制数据（包含\\0），同时在PHP中，求字符串长度strlen是O(1)操作。")]),a._v(" "),t("p",[a._v("在新增、修改、追加字符串操作时，PHP都会重新分配内存生成新的字符串。最后，出于安全考虑，PHP在生成一个字符串时末尾仍然会添加\\0。")]),a._v(" "),t("h3",{attrs:{id:"数组"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组","aria-hidden":"true"}},[a._v("#")]),a._v(" 数组")]),a._v(" "),t("p",[a._v("PHP的数组通过Zend HashTable来天然实现。")]),a._v(" "),t("p",[a._v("foreach操作如何实现？对一个数组的foreach就是通过遍历hashtable中的双向链表完成。对于索引数组，通过foreach遍历效率比for高很多，省去了key->value的查找。count操作直接调用HashTable->NumOfElements，O(1)操作。对于 '123' 这样的字符串，zend会转换为其整数形式。$arr['123']和$arr[123]是等价的。")]),a._v(" "),t("h3",{attrs:{id:"资源"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#资源","aria-hidden":"true"}},[a._v("#")]),a._v(" 资源")]),a._v(" "),t("p",[a._v("资源类型变量是PHP中最复杂的一种变量，也是一种复合型结构。")]),a._v(" "),t("p",[a._v("PHP的zval可以表示广泛的数据类型，但是对于自定义的数据类型却很难充分描述。由于没有有效的方式描绘这些复合结构，因此也没有办法对它们使用传统的操作符。要解决这个问题，只需要通过一个本质上任意的标识符（label）引用指针，这种方式被称为资源。")]),a._v(" "),t("p",[a._v("在zval中，对于resource，lval作为指针来使用，直接指向资源所在的地址。Resource可以是任意的复合结构，我们熟悉的mysqli、fsock、memcached等都是资源。")]),a._v(" "),t("p",[a._v("如何使用资源：")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("注册：对于一个自定义的数据类型，要想将它作为资源。首先需要进行注册，zend会为它分配全局唯一标示。")])]),a._v(" "),t("li",[t("p",[a._v("获取一个资源变量：对于资源，zend维护了一个id->实际数据的hash_tale。对于一个resource，在zval中只记录了它的id。fetch的时候通过id在hash_table中找到具体的值返回。")])]),a._v(" "),t("li",[t("p",[a._v("资源销毁：资源的数据类型是多种多样的。Zend本身没有办法销毁它。因此需要用户在注册资源的时候提供销毁函数。当unset资源时，zend调用相应的函数完成析构。同时从全局资源表中删除它。\n资源可以长期驻留，不只是在所有引用它的变量超出作用域之后，甚至是在一个请求结束了并且新的请求产生之后。这些资源称为持久资源，因为它们贯通SAPI的整个生命周期持续存在，除非特意销毁。很多情况下，持久化资源可以在一定程度上提高性能。比如我们常见的mysql_pconnect ,持久化资源通过pemalloc分配内存，这样在请求结束的时候不会释放。 对zend来说，对两者本身并不区分")])])])])}],!1,null,null,null);s.options.__file="var.md";e.default=s.exports}}]);