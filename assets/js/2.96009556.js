(window.webpackJsonp=window.webpackJsonp||[]).push([[2],{170:function(t,a,e){t.exports=e.p+"assets/img/message.7b13ee00.png"},171:function(t,a,e){t.exports=e.p+"assets/img/tcp.901c36fc.png"},172:function(t,a,e){t.exports=e.p+"assets/img/4_closes.4942899c.png"},201:function(t,a,e){"use strict";e.r(a);var v=[function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("div",{staticClass:"content"},[v("h1",{attrs:{id:"tcp"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp","aria-hidden":"true"}},[t._v("#")]),t._v(" TCP")]),t._v(" "),v("h2",{attrs:{id:"协议描述"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#协议描述","aria-hidden":"true"}},[t._v("#")]),t._v(" 协议描述")]),t._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[t._v("描述")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("为应用层提供可靠的、面向连接的和基于流的服务。")])]),t._v(" "),v("li",[v("p",[t._v("使用超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因此服务是可靠的。")])]),t._v(" "),v("li",[v("p",[t._v("使用TCP协议通信的双方必须先建立TCP连接，并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以释放这些内核数据。")])]),t._v(" "),v("li",[v("p",[t._v("TCP基于流。基于流的数据没有边界（长度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个地向数据流中写入数据，接收端也可以逐个地将它们读出。")])])])]),t._v(" "),v("h2",{attrs:{id:"优点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#优点","aria-hidden":"true"}},[t._v("#")]),t._v(" 优点")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("可供可靠服务")])]),t._v(" "),v("li",[v("p",[t._v("无差错，不丢失，不重复，且按序到达")])])]),t._v(" "),v("h2",{attrs:{id:"缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#缺点","aria-hidden":"true"}},[t._v("#")]),t._v(" 缺点")]),t._v(" "),v("ul",[v("li",[t._v("慢")]),t._v(" "),v("li",[t._v("效率低")]),t._v(" "),v("li",[t._v("占用系统资源高")]),t._v(" "),v("li",[t._v("易被攻击")])]),t._v(" "),v("h2",{attrs:{id:"适用场景"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#适用场景","aria-hidden":"true"}},[t._v("#")]),t._v(" 适用场景")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("对数据传输的质量有较高要求，但对实时性要求不高。")])]),t._v(" "),v("li",[v("p",[t._v("比如HTTP，HTTPS，FTP等传输文件的协议以及POP，SMTP等邮件传输的协议，应选用TCP协议。")])])]),t._v(" "),v("h2",{attrs:{id:"三次握手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三次握手","aria-hidden":"true"}},[t._v("#")]),t._v(" 三次握手")]),t._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[t._v("名词")]),t._v(" "),v("p",[t._v("在TCP/IP协议中,TCP协议提供可靠的连接服务,采用三次握手建立一个连接.")])]),t._v(" "),v("h3",{attrs:{id:"报文格式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#报文格式","aria-hidden":"true"}},[t._v("#")]),t._v(" 报文格式")]),t._v(" "),v("h4",{attrs:{id:"图例："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#图例：","aria-hidden":"true"}},[t._v("#")]),t._v(" 图例：")]),t._v(" "),v("img",{staticStyle:{width:"500px"},attrs:{src:e(170)}}),t._v(" "),v("h4",{attrs:{id:"序号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#序号","aria-hidden":"true"}},[t._v("#")]),t._v(" 序号")]),t._v(" "),v("ul",[v("li",[t._v("Seq")])]),t._v(" "),v("p",[t._v("用来标识从TCP源端向目的端发送的字节流，发起方发送数据时对此进行标记。")]),t._v(" "),v("h4",{attrs:{id:"确认序号"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#确认序号","aria-hidden":"true"}},[t._v("#")]),t._v(" 确认序号")]),t._v(" "),v("ul",[v("li",[t._v("Ack序号")])]),t._v(" "),v("p",[t._v("占32位，只有ACK标志位为1时，确认序号字段才有效，Ack=Seq+1。")]),t._v(" "),v("h4",{attrs:{id:"标志位"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#标志位","aria-hidden":"true"}},[t._v("#")]),t._v(" 标志位")]),t._v(" "),v("ul",[v("li",[t._v("URG： 紧急指针（urgent pointer）有效。")]),t._v(" "),v("li",[t._v("ACK： 确认序号有效。")]),t._v(" "),v("li",[t._v("PSH： 接收方应该尽快将这个报文交给应用层。")]),t._v(" "),v("li",[t._v("RST： 重置连接。")]),t._v(" "),v("li",[t._v("SYN： 发起一个新连接。")]),t._v(" "),v("li",[t._v("FIN： 释放一个连接。")])]),t._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[t._v("需要注意的是：")]),t._v(" "),v("ul",[v("li",[t._v("不要将确认序号Ack与标志位中的ACK搞混了。")]),t._v(" "),v("li",[t._v("确认方Ack=发起方Seq+1，两端配对。")])])]),t._v(" "),v("h4",{attrs:{id:"服务状态标志"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#服务状态标志","aria-hidden":"true"}},[t._v("#")]),t._v(" 服务状态标志")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("ESTABLISHED")]),t._v(" "),v("p",[t._v("建立了")])]),t._v(" "),v("li",[v("p",[t._v("SYN_RECE")]),t._v(" "),v("p",[t._v("Server 建立一个新的连接，等待接受")])]),t._v(" "),v("li",[v("p",[t._v("SYN_SENT")]),t._v(" "),v("p",[t._v("Client 建立一个新的连接，等待发送")])])]),t._v(" "),v("h3",{attrs:{id:"握手过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#握手过程","aria-hidden":"true"}},[t._v("#")]),t._v(" 握手过程")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("图例：\n"),v("img",{attrs:{src:e(171)}})])]),t._v(" "),v("li",[v("p",[t._v("解释：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("第一次握手：Client将标志位SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。")])]),t._v(" "),v("li",[v("p",[t._v("第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。")])]),t._v(" "),v("li",[v("p",[t._v("第三次握手：Client收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。")])])])])]),t._v(" "),v("h2",{attrs:{id:"syn攻击"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#syn攻击","aria-hidden":"true"}},[t._v("#")]),t._v(" SYN攻击")]),t._v(" "),v("p",[t._v("在三次握手过程中，Server发送SYN-ACK之后，收到Client的ACK之前的TCP连接称为半连接（half-open connect），此时Server处于SYN_RCVD状态，当收到ACK后，Server转入ESTABLISHED状态。")]),t._v(" "),v("p",[t._v("SYN攻击就是Client在短时间内伪造大量不存在的IP地址，并向Server不断地发送SYN包，Server回复确认包，并等待Client的确认，由于源地址是不存在的，因此，Server需要不断重发直至超时，这些伪造的SYN包将产时间占用未连接队列，导致正常的SYN请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。")]),t._v(" "),v("p",[t._v("SYN攻击时一种典型的DDOS攻击，检测SYN攻击的方式非常简单，即当Server上有大量半连接状态且源IP地址是随机的，则可以断定遭到SYN攻击了。")]),t._v(" "),v("p",[t._v("使用如下命令可以让之现行：")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("#netstat -nap | grep SYN_RECV\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("h2",{attrs:{id:"四次挥手"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四次挥手","aria-hidden":"true"}},[t._v("#")]),t._v(" 四次挥手")]),t._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[t._v("描述")]),t._v(" "),v("p",[t._v("所谓四次挥手（Four-Way Wavehand）即终止TCP连接，就是指断开一个TCP连接时，需要客户端和服务端总共发送4个包以确认连接的断开。")]),t._v(" "),v("p",[t._v("在socket编程中，这一过程由客户端或服务端任一方执行close来触发，整个流程如下图所示：")])]),t._v(" "),v("div",{staticClass:"tip custom-block"},[v("p",{staticClass:"custom-block-title"},[t._v("概要")]),t._v(" "),v("p",[t._v("由于TCP连接时全双工的，因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。")]),t._v(" "),v("p",[t._v("首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭，上图描述的即是如此。")])]),t._v(" "),v("h3",{attrs:{id:"挥手过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#挥手过程","aria-hidden":"true"}},[t._v("#")]),t._v(" 挥手过程")]),t._v(" "),v("ul",[v("li",[t._v("图例：")])]),t._v(" "),v("img",{staticStyle:{width:"700px"},attrs:{src:e(172)}}),t._v(" "),v("ul",[v("li",[v("p",[t._v("解释：")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。")])]),t._v(" "),v("li",[v("p",[t._v("服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。")])]),t._v(" "),v("li",[v("p",[t._v("客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。")])]),t._v(" "),v("li",[v("p",[t._v("服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。")])]),t._v(" "),v("li",[v("p",[t._v("客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。")])]),t._v(" "),v("li",[v("p",[t._v("服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。")])])])])])])}],s=e(0),_=Object(s.a)({},function(){this.$createElement;this._self._c;return this._m(0)},v,!1,null,null,null);_.options.__file="tcp.md";a.default=_.exports}}]);